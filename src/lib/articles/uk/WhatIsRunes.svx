# Руни в Svelte

З виходом Svelte 5 нам були представлені руни. Як казав сам Річ Гарріс, вони слугують для того, щоб прибрати "магію" з коду. Під "магією" він мав на увазі ситуацію, коли let за замовчуванням ставав реактивним. Це викликало плутанину серед розробників, особливо тих, хто переходив з інших фреймворків. Нова система рун робить реактивність більш явною та передбачуваною.

## Основні руни

1. ### $state  
   Це основна руна, яку ви будете використовувати в коді. Вона замінила собою "магічний" let та використовується для визначення реактивного значення в коді.  Приклад коду:у:**  
  
   ```JavaScript
   let count = $state(0); // замість let count = 0;
   ```  
   
 
   Ця руна робить код більш зрозумілим, оскільки реактивність тепер оголошується явно.

2. ### $derived  
   Ця руна використовується як заміна реактивного значення в Svelte 4, наприклад, $: c = a + b. Вона також виконує функцію, схожу на хук useMemo у React. При цьому вона власноруч визначає залежності для перерахунку свого значеннПриклад коду: коду:**  
   ```JavaScript
   let a = $state(1);  
   let b = $state(2);  
   let total = $derived(a + b);  
   ```
 
   Ця руна допомагає уникнути зайвих перерахунків, оскільки вона автоматично відстежує зміни залежностей.

3. ### $effect  
   Як каже документація, цю руну ви будете використовувати дуже рідко. Її основне призначення — виконання побічних ефектів при зміні реактивного значення, наприклад, відправка запиту до API. З власного досвіду можу сказати, що з нею потрібно бути обережним, бо дуже легкstack overflowk overflow** при неправильному використанні. Це трапляється, наприклад, коли руна викликає сама себе через зміну залежнПриклад коду:клад коду:**  
  
   ```JavaScript
   let count = $state(0);  

   $effect(() => {  
       console.log('Count changed:', count);  
   });  
   ```
 
   Ця руна корисна для виконання дій, які повинні відбуватися при зміні стану, але її варто використовувати з обережністю.
   
   ### $inspect  
   З назви ви вже зрозуміли, що це руна для налагодження. Її основне використання — це відстеження оновлень реактивного значення. Це свого роду console.log, який показує актуальне значення змінної як при початковому стані, так і при його оновПриклад коду:клад коду:**  
  
   ```JavaScript
   let count = $state(0);  
   $inspect(count); // Виводить значення count при кожній зміні  
   ```
   Ця руна дуже корисна для дебагінгу, оскільки вона показує стан змінної в реальному часі.Що ж стало краще?ало краще?**

## Нові можливості
Окрім того, що зараз ми явно оголошуємо реактивний стан за допомогою руни $state, що покращило читабельність коду, ми також можемо використовувати реактивність у файлах поза .svelte. Це дозволяє створювати файли з логікою, які можна використовувати по всьому застосунку. Наприклад, ми можемо створити звичайний клас у файлі .svelte.ts і використовувати його всюди, будучи впевненими, що значення завжди буде акПриклад коду:клад коду:**  
```JavaScript
class Counter {  
    count = $state(0);  
    increment() { this.count++; }  
}  

const counter = new Counter();  
```

Цей підхід робить код більш модульним і легшим для повторного використання.

З власного досвіду можу сказати, що такі файли працюють навіть краще, ніstoresі **stores**. Хоч вони і мають схожу функціstores, **stores** все ще існують паралельно, і їх не планують прибирати в найближчому майбутньому. Однак руни можуть стати більш популярними через свою простоту та універсПриклад порівняння з івняння з **stores****:  
```JavaScript
// Раніше:  
import { writable } from 'svelte/store';  
const count = writable(0);  

// Зараз:  
let count = $state(0);  
```
## **Новий CLI**

З виходом Svelte 5 команда також презентувала новий інструмент — sv cli для зручної роботи зі Svelte 5.  
Приклад команди для створення нового проекту:  

```
npx create-svelte@latest my-app  
``` 

Цей CLI дозволяє створити новий репозиторій з усіма необхідними інтеграціями: від авторизації до багатомовності. Плюсом є наявність демо-файлів для всіх цих інтеграцій, щоб ви могли зрозуміти, як із ними працювати.

Величезною перевагою цього CLI є автоматична міграція зі Svelte 4 до Svelte 5. На простих застосунках він зробить усі міграції за вас, так що вам навіть не потрібно буде додавати нічого, щоб код працював як раніше. Однак для складних застосунків можуть знадобитися ручні правки.  
Приклад команди для міграції:

```powers hell
npx svelte-migrate  
```

#### Висновок

Для першого знайомства з рунами, гадаю, цього буде достатньо. У наступній статті я хотів би більше розібрати новий інструментарій sv CLI та більше поговорити про метафреймворк для Svelte — SvelteKit. Ви можете ознайомитися з офіційною документацією SvelteKit за посиланням: <a href="https://kit.svelte.dev/" target="_blank">SvelteKit Docs</a>.

Дякую за те, що прочитали це, і до наступної зустрічі!